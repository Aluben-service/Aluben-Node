!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).BareMux={})}(this,function(e){"use strict";let t=globalThis.fetch,r=globalThis.WebSocket,a=globalThis.Request,o=globalThis.Response,s=globalThis.SharedWorker,n=globalThis.localStorage,i=globalThis.navigator.serviceWorker,c={prototype:{send:r.prototype.send},CLOSED:r.CLOSED,CLOSING:r.CLOSING,CONNECTING:r.CONNECTING,OPEN:r.OPEN};async function l(){let e=await self.clients.matchAll({type:"window",includeUncontrolled:!0}),t=e.map(async e=>{var t;let r,a=await (t=e,r=new MessageChannel,new Promise(e=>{t.postMessage({type:"getPort",port:r.port2},[r.port2]),r.port1.onmessage=t=>{e(t.data)}}));return await p(a),a}),r=Promise.race([Promise.any(t),new Promise((e,t)=>setTimeout(t,1e3,TypeError("timeout")))]);try{return await r}catch(a){if(a instanceof AggregateError)throw console.error("bare-mux: failed to get a bare-mux SharedWorker MessagePort as all clients returned an invalid MessagePort."),Error("All clients returned an invalid MessagePort.");return console.warn("bare-mux: failed to get a bare-mux SharedWorker MessagePort within 1s, retrying"),await l()}}function p(e){let t=new MessageChannel,r=new Promise((e,r)=>{t.port1.onmessage=t=>{"pong"===t.data.type&&e()},setTimeout(r,1500)});return e.postMessage({message:{type:"ping"},port:t.port2},[t.port2]),r}function d(e,t){let r=new s(e,"bare-mux-worker");return t&&i.addEventListener("message",t=>{if("getPort"===t.data.type&&t.data.port){console.debug("bare-mux: recieved request for port from sw");let r=new s(e,"bare-mux-worker");t.data.port.postMessage(r.port,[r.port])}}),r.port}let h=null;function u(){if(null!==h)return h;{let e=new MessageChannel,t=new ReadableStream,r;try{e.port1.postMessage(t,[t]),r=!0}catch(a){r=!1}return h=r,r}}class w{constructor(e){this.channel=new BroadcastChannel("bare-mux"),e instanceof MessagePort?this.port=e:this.createChannel(e,!0)}createChannel(e,t){if(self.clients)this.port=l(),this.channel.onmessage=e=>{"refreshPort"===e.data.type&&(this.port=l())};else if(e&&s){if(!e.startsWith("/")&&!e.includes("://"))throw Error("Invalid URL. Must be absolute or start at the root.");this.port=d(e,t),console.debug("bare-mux: setting localStorage bare-mux-path to",e),n["bare-mux-path"]=e}else if(s){let r=n["bare-mux-path"];if(console.debug("bare-mux: got localStorage bare-mux-path:",r),!r)throw Error("Unable to get bare-mux workerPath from localStorage.");this.port=d(r,t)}else throw Error("Unable to get a channel to the SharedWorker.")}async sendMessage(e,t){this.port instanceof Promise&&(this.port=await this.port);try{await p(this.port)}catch{return console.warn("bare-mux: Failed to get a ping response from the worker within 1.5s. Assuming port is dead."),this.createChannel(),await this.sendMessage(e,t)}let r=new MessageChannel,a=[r.port2,...t||[]],o=new Promise((e,t)=>{r.port1.onmessage=r=>{let a=r.data;"error"===a.type?t(a.error):e(a)}});return this.port.postMessage({message:e,port:r.port2},a),await o}}function f(e,t,r){console.error(`error while processing '${r}': `,t),e.postMessage({type:"error",error:t})}async function g(e,t,r){let a=await r.request(new URL(e.fetch.remote),e.fetch.method,e.fetch.body,e.fetch.headers,null);if(!u()&&a.body instanceof ReadableStream){let s=new o(a.body);a.body=await s.arrayBuffer()}a.body instanceof ReadableStream||a.body instanceof ArrayBuffer?t.postMessage({type:"fetch",fetch:a},[a.body]):t.postMessage({type:"fetch",fetch:a})}async function y(e,t,r){let a=t=>{e.websocket.channel.postMessage({type:"open",args:[t]})},o=(t,r)=>{e.websocket.channel.postMessage({type:"close",args:[t,r]})},s=t=>{e.websocket.channel.postMessage({type:"error",args:[t]})},n=t=>{t instanceof ArrayBuffer?e.websocket.channel.postMessage({type:"message",args:[t]},[t]):e.websocket.channel.postMessage({type:"message",args:[t]})},[i,c]=r.connect(new URL(e.websocket.url),e.websocket.origin,e.websocket.protocols,e.websocket.requestHeaders,a,n,o,s);e.websocket.channel.onmessage=e=>{"data"===e.data.type?i(e.data.data):"close"===e.data.type&&c(e.data.closeCode,e.data.closeReason)},t.postMessage({type:"websocket"})}function b(e){for(let t=0;t<e.length;t++){let r=e[t];if(!"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~".includes(r))return!1}return!0}let m=["ws:","wss:"],k=[101,204,205,304],$=[301,302,303,307,308];class M{constructor(e){this.worker=new w(e)}createWebSocket(e,t=[],a,o,s){try{e=new URL(e)}catch(n){throw new DOMException(`Faiiled to construct 'WebSocket': The URL '${e}' is invalid.`)}if(!m.includes(e.protocol))throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${e.protocol}' is not allowed.`);for(let i of(Array.isArray(t)||(t=[t]),t=t.map(String)))if(!b(i))throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${i}' is invalid.`);let l=a||r,p=new l("ws://127.0.0.1:1",t),d="",h=c.CONNECTING,u=!1;p.addEventListener("error",e=>{u||(h=r.CONNECTING,e.stopImmediatePropagation(),u=!0)});let w=!1;p.addEventListener("close",e=>{w||(e.stopImmediatePropagation(),w=!0)}),s=s||l.constructor.constructor("return ArrayBuffer")().prototype,(o=o||{}).Host=new URL(e).host,o.Pragma="no-cache",o["Cache-Control"]="no-cache",o.Upgrade="websocket",o.Connection="Upgrade";let f=e=>{h=c.OPEN,d=e,p.meta={headers:{"sec-websocket-protocol":e}},p.dispatchEvent(new Event("open"))},g=async e=>{"string"==typeof e?p.dispatchEvent(new MessageEvent("message",{data:e})):"byteLength"in e?("blob"===p.binaryType?e=new Blob([e]):Object.setPrototypeOf(e,s),p.dispatchEvent(new MessageEvent("message",{data:e}))):"arrayBuffer"in e&&("arraybuffer"===p.binaryType&&Object.setPrototypeOf(e=await e.arrayBuffer(),s),p.dispatchEvent(new MessageEvent("message",{data:e})))},y=(e,t)=>{h=c.CLOSED,p.dispatchEvent(new CloseEvent("close",{code:e,reason:t}))},k=()=>{h=c.CLOSED,p.dispatchEvent(new Event("error"))},$=new MessageChannel;$.port1.onmessage=e=>{"open"===e.data.type?f(e.data.args[0]):"message"===e.data.type?g(e.data.args[0]):"close"===e.data.type?y(e.data.args[0],e.data.args[1]):"error"===e.data.type&&k()},this.worker.sendMessage({type:"websocket",websocket:{url:e.toString(),origin:origin,protocols:t,requestHeaders:o,channel:$.port2}},[$.port2]);let M=()=>h;Object.defineProperty(p,"readyState",{get:M,configurable:!0,enumerable:!0});let C=()=>{let e=M();if(e===c.CONNECTING)return new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.")};return p.send=function(...e){let t=C();if(t)throw t;let r=e[0];r.buffer&&(r=r.buffer),$.port1.postMessage({type:"data",data:r},r instanceof ArrayBuffer?[r]:[])},p.close=function(e,t){$.port1.postMessage({type:"close",closeCode:e,closeReason:t})},Object.defineProperty(p,"url",{get:()=>e.toString(),configurable:!0,enumerable:!0}),Object.defineProperty(p,"protocol",{get:()=>d,configurable:!0,enumerable:!0}),p}async fetch(e,r){let s=new a(e,r),n=r?.headers||s.headers,i=n instanceof Headers?Object.fromEntries(n):n,c=s.body,l=new URL(s.url);if(l.protocol.startsWith("blob:")){let p=await t(l),d=new o(p.body,p);return d.rawHeaders=Object.fromEntries(p.headers),d.rawResponse=p,d}for(let h=0;;h++){"host"in i?i.host=l.host:i.Host=l.host;let u=(await this.worker.sendMessage({type:"fetch",fetch:{remote:l.toString(),method:s.method,headers:i,body:c||void 0}},c?[c]:[])).fetch,w=new o(k.includes(u.status)?void 0:u.body,{headers:new Headers(u.headers),status:u.status,statusText:u.statusText});w.rawHeaders=u.headers,w.rawResponse=new o(u.body),w.finalURL=l.toString();let f=r?.redirect||s.redirect;if(!$.includes(w.status))return w;switch(f){case"follow":{let g=w.headers.get("location");if(20>h&&null!==g){l=new URL(g,l);continue}throw TypeError("Failed to fetch")}case"error":throw TypeError("Failed to fetch");case"manual":return w}}}}e.BareClient=M,e.BareMuxConnection=class e{constructor(e){this.worker=new w(e)}async getTransport(){return(await this.worker.sendMessage({type:"get"})).name}async setTransport(e,t,r){await this.setManualTransport(`
			const { default: BareTransport } = await import("${e}");
			return [BareTransport, "${e}"];
		`,t,r)}async setManualTransport(e,t,r){if("bare-mux-remote"===e)throw Error("Use setRemoteTransport.");await this.worker.sendMessage({type:"set",client:{function:e,args:t}},r)}async setRemoteTransport(e,t){let r=new MessageChannel;r.port1.onmessage=async t=>{let r=t.data.port,a=t.data.message;if("fetch"===a.type)try{e.ready||await e.init(),await g(a,r,e)}catch(o){f(r,o,"fetch")}else if("websocket"===a.type)try{e.ready||await e.init(),await y(a,r,e)}catch(s){f(r,s,"websocket")}},await this.worker.sendMessage({type:"set",client:{function:"bare-mux-remote",args:[r.port2,t]}},[r.port2])}getInnerPort(){return this.worker.port}},e.WebSocketFields=c,e.WorkerConnection=w,e.browserSupportsTransferringStreams=u,e.default=M,e.maxRedirects=20,e.validProtocol=b,Object.defineProperty(e,"__esModule",{value:!0})});
